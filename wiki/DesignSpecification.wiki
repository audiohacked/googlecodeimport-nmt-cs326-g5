#summary We can do our design specification here.

=Digital Content Distribution and Publishing System=
==Team # 5==

=Design Specification=

==1. Project Overview==

The program will provide a cross-platform content distribution and publishing service. It will use a client-server model where the server will use and provide service through standard programs/services like Apache and MySQL. The customer can choose to use the server to distribute published files or allow users to upload their own content that can be sponsored/featured on the server.

The motivation for this project is the lack of a general-purpose, platform-independent content distribution service on the market.  Many content distribution services, such as Valve's Steam platform for game distribution, Apple's iTunes service for music distribution, or Netflix's online movie watching software, have some form of platform-dependency (whether it be a an operating system or browser) and/or are content-specific; that is to say that they allow the distribution of only certain forms of digital content.


===1.1 Scope and Objectives===

The scope of the project is to build a base platform for customers to create a digital community and publishing system while also supporting at least Linux, Windows, and Mac users alike. The main function of the system is to provide an end-user a way to obtain any digital content, such as movies, music, and other entertainment. The system has to be fast, native-looking, and easily changeable/upgradeable. To insure the user's client is up to date, it will include an self updater. To facilitate downloading, the client will use BitTorrent and HTTP. Finally, the client can also be configured to include Community Portal and/or a web browser.

===1.2 Supplementary Requirements===

*FURPS Non-functional Requirements (Quality)*

_Usability_
  * Users familiar with other content distribution platforms and file transfer clients should feel at ease with this system.
  * User interface should always strive for simplicity and intuitiveness.
  * User interface should follow a tabbed system to divide functionality and reduce complexity.

_Reliability_
  * The entire system must be robust enough to handle common networking issues like dropped connections, missing files, and transfer errors.
  * User authentication system should use common security practices.

_Performance_
  * File transfers should initiate within two seconds of a client's request.
  * Content server should responsibly manage available bandwidth to achieve optimal browsing and transfer speeds.

_Supportability_
  * Content server's closed website system should be mostly dynamic, adapting to file additions/removals as well as changes in existing files' properties.

*FURPS+ Additional Non-functional Requirements (Constraints)*

_Implementation_
  * The client will be implemented in C++, utilizing the gtkWidgets library for cross-platform code.

==2. Customer Requirements==
*Use-Case Diagram - Entire System*

http://nmt-cs326-g5.googlecode.com/files/usecasev2_2.jpeg

*Actor Descriptions and Use-Cases by Actor*

`BasicUser` - the target audience for downloads, uses the client software.

http://nmt-cs326-g5.googlecode.com/files/UseCase_BasicUser.jpeg

----

`ContentDistributor` - the manager of the Centralized Content Server, inherits functionality from Basic User.

http://nmt-cs326-g5.googlecode.com/files/UseCase_ContentDistributor.jpeg

----

`DBManager` - provides storage and retrieval for information on downloads. This includes file location, file attributes, statistics including number of downloads, and other vital information.

http://nmt-cs326-g5.googlecode.com/files/UseCase_Database.jpeg

----

`ContentServer` - communicates with the client software and the database. Is responsible for communication between client and database.

http://nmt-cs326-g5.googlecode.com/files/UseCase_ContentServer.jpeg

----

`Tracker` - communicates with the client software during a torrent download to provide connection information to peers.

http://nmt-cs326-g5.googlecode.com/files/UseCase_Tracker.jpeg


*Deployment Diagram*

http://nmt-cs326-g5.googlecode.com/files/DeploymentDiagram.jpeg


==3. Architectural Design==

Our project is utilizing the Model-View-Controller (MVC) architecture to effectively reduce complexity and separate application entities (files, database storage) from business logic (file transfer) and boundary entities (user interface).  

Other architectures were considered, including the Client-Server model and Peer-To-Peer model, but these architectures only encompass part of the functionality of application.  We have, however, adhered to many of the guiding principles behind these architectures while structuring our application under MVC.

===3.1 Subsystem Architecture===

This section should include a subsystem dependency diagram and supporting discussion. 
http://nmt-cs326-g5.googlecode.com/files/subsystem_architecture_v1.jpeg

This diagram is divided into three distinct layers; model, view, and controller.  Following the MVC architecture and philosophy, subsystems performing boundary actions are in the view layer.  These subsystems consist of the User Interface (composed of the GUI and in-house web browser subsystems) and the Server subsystem.  The User Interface handles virtually every interaction with the user, the Server subsystem represents the centralized content server with which the client interacts.

The controller layer consists of subsystems which perform the vast majority of business logic for the application.  This layer contains the wxWidgets, Transfer Manager, Database Manager, and Content Manager subsystems.  The wxWidgets system represents the wxWidgets API, which allows our application to be platform-independent and is responsible for rendering the client and implementing the web browser.  The TransferManager is an abstract subsystem, realized by two subsystems, the HTTP Transfer Manager and the Torrent Transfer Manager, which handle and implement the code to perform transfers over their respective protocols between clients and the centralized content server, as well as between clients (in the case of a torrent transfer) and a tracker.  The Database Manager subsystem is responsible for handling requests from both client and server concerning the centralized database, as well as connecting to and performing transactions with that database.  Finally, the Content Manager subsystem is a server-side subsystem which manages requests for files from clients.  The Content Manager also provides the necessary functionality to perform user authentication and administrative actions for users who are "Content Distributors".  

The lowest level of the architecture is the model layer, and is comprised of only three subsystems; an OS-specific GUI Library, the Local File System, and a mySQL Database.   The OS-specific GUI Library is a dynamic system, controlled by the wxWidgets subsystem to perform rendering actions on a specific operating system.  The internal class hierarchy related to these subsystems follows a bridge design pattern for separating the implementation of GUI concepts (windows, menus, dialogs, etc.) from an OS-specific implementation of those concepts.  The second subsystem, the Local File System, is also a generic subsystem which is largely implemented by system API's.  This subsystem is responsible for storing files which are downloaded to clients and uploaded by clients to the content server.  Finally, the third subsystem, the mySQL Database, consists of the actual relational schema and physical tables of application data in the mySQL DBMS.  This subsystem is controlled exclusively by the Database Manager subsystem.


===3.2 Deployment Model===

http://nmt-cs326-g5.googlecode.com/files/deployment_diagram_v2.JPG

The deployment model for the application is fairly traditional; client-side systems are mapped to the client executable, server systems (Content Manager) are mapped to a server side applet, and the database subsystem is mapped to a mySQL database.  One content server supports many clients, and one database instance is tied to one server.  

==4. Use Case Realization Design==

Specific use case descriptions and sequence diagrams:

_Use Case Name_      *`DownloadFile`* _(Also applies to *'DownloadHTTPFile'*)_

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_abstractdownload.jpeg

http://nmt-cs326-g5.googlecode.com/files/downloadFileClassDiagram.png

This generic use case includes all more specific download use cases, which include HTTP and Torrent downloads, at this time. The Basic User selects the download in the GUI, which then communicates the request for the download to the proper TransferManager, which is specific to each type of transfer. The transfer manager then initiates a connection with the server to be downloaded from, using information from the ContentManager server.

----

_Use Case Name_        *`DownloadTorrentFile`*

http://nmt-cs326-g5.googlecode.com/files/seq_downloadtorrentfile.jpg

http://nmt-cs326-g5.googlecode.com/files/downloadTorrentFileClassDiagram.png

The user selects a file or set of files to download, which are associated with the torrent download type. The GUI then communicates the download request to the Torrent Transfer Manager, which then communicates with the ContentManager to get the proper information, as well as the torrent file. The Torrent Transfer Manager then interprets the torrent file and the location of the torrent tracker. The Torrent Transfer Manager then communicates with the torrent tracker and receives the location of peers with the desired download.


----

_Use Case Name_      *`ReportFileDownload`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_reportfiledownload.jpeg

http://nmt-cs326-g5.googlecode.com/files/reportFileDownloadClassDiagram.png

The ContentManager checks to be sure it has an open connection to the DBManager, which manages the actual connection to the database. If the connection is ready, the ContentManager communicates it's request to the DBManager, and then DBManager signals it is ready for the data. ContentManager then communicates the report of the file download, which is then inserted into the database. DBManager then reports to ContentManager its success or failure.

----

_Use Case Name_  *`ReportFileUpload`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_reportfileupload.jpeg

http://nmt-cs326-g5.googlecode.com/files/ReportFileUploadClassDiagram.png

The ContentManager checks to be sure it has an open connection to the DBManager, which manages the actual connection to the database. If the connection is ready, the ContentManager communicates it's request to the DBManager, and then DBManager signals it is ready for the data. ContentManager then communicates the report of the file upload, including the attributes and location of the file, which is then inserted into the database. DBManager then reports to ContentManager its success or failure.

----

_Use Case Name_  *`UploadFile`*

*Activity Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_uploadfile.jpg

http://nmt-cs326-g5.googlecode.com/files/UploadFileClassDiagram.png

The authenticated user communicates a request to the content manager to upload a file. The content manager checks with the database if the user is allowed to upload files. If the user is properly authorized, they select the file type and location, and upload the file to the server. The user is prompted by the GUI for information pertaining to the file, and the content manager receives the file and information, and inserts the proper data into the database through the DBManager.

----

_Use Case Name_  *`DesignateFileSponsoredStatus`*

http://nmt-cs326-g5.googlecode.com/files/seq_designatefilesponsoredstatus.jpg

http://nmt-cs326-g5.googlecode.com/files/designateFileSponsoredStatusClassDiagram.png

An authenticated user uses the GUI to select a file that they want to designate the sponsored status upon. The GUI then contacts the Content Manager, which then checks with DBManager to make sure the user is a Content Distributor. If the user is a Content Distributor, then the original request is carried out by the Content Manager, which sends the proper command to the DBManager.

----

_Use case name_  *`GetFileStatistics`*


http://nmt-cs326-g5.googlecode.com/files/seq_getfilestatistics.jpg

http://nmt-cs326-g5.googlecode.com/files/GetFileStatisticsClassdiagram.png

The Content Manager requests file statistics through the DBManger, which has the actual connection to the database. The DBManager responds with either the data or an error code.
----

_Use case name_  *`ReportTransferProgress`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_reporttransferprogress2.JPG

http://nmt-cs326-g5.googlecode.com/files/ReportTransferProgressClassD.png

----

_Use case name_  *`BrowseContentSite`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_browsecontent.jpeg

This use case covers the in-client web browsing of the centralized content server.  Essentially, a user requests a particular web page; the GUI relays the request to the ContentManager class, which then returns the requested data to the client, which is then rendered by the GUI.

http://nmt-cs326-g5.googlecode.com/files/browseContentSiteClassDiagram2.png

This interaction involves two classes; the GUI and the ContentManager.  The multiplicity of this relationship merely indicates that one ContentManager can service multiple GUI's (client applications).

----

_Use case name_  *`RemoveFile`*

*Activity Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_removefile.jpg

http://nmt-cs326-g5.googlecode.com/files/removeFileClassDiagram2.png

----

_Use case name_  *`SetClientPreferences`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_setclientpreferences.jpeg

http://nmt-cs326-g5.googlecode.com/files/SetClientPreferencesClassDiagram.png

----

_Use case name_  *`SetServerPreferences`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_setserverpreferences.jpeg

http://nmt-cs326-g5.googlecode.com/files/SetServerPreferencesClassDiagram.png

----

_Use Case Name_        *`AbortFileTransfer`*

*Activity Diagram*

http://nmt-cs326-g5.googlecode.com/files/act_aborttransfer.jpeg

http://nmt-cs326-g5.googlecode.com/files/abortFileTransferClassDiagram.png




==5. Subsystem Design==

===5.1 User Interface===
This set of subsystems is comprised entirely of one class, the 'GUI' class.  This class is pictured below:

http://nmt-cs326-g5.googlecode.com/files/class_gui_v2.JPG

The subsystem's internal associations are depicted below:

http://nmt-cs326-g5.googlecode.com/files/ssinteraction_ui_v1.jpeg

The functionality of this class is described in terms of the next three subsystems of the User Interface.

*5.1.1 GUI*

This subsystem implements the graphical user interface via the wxWidgets libraries.  When the GUI class is invoked (via the invoke() method), it establishes all the necessary wxWidgets components and events to manage the graphical user interface.  In addition, methods like openPreferenceDialog() and initiateUpload() handle common boundary actions between users and the client.  

*5.1.2 Web Browser*

The Web Browser subsystem is handled entirely by the viewWebContent() method.  This method handles the transfer of web content from the ContentManager class (see the Content Manager subsystem) and is primarily responsible for displaying web content via the in-house browser and passing along download requests to other subsystems via methods like initiateDownload().

*5.1.3 wxWidgets*

The wxWidgets subsystem represents the wxWidgets library, which the application makes heavy use of in order to create a cross-platform client which maintains the "look and feel" of a native application.  The GUI class is essentially a wrapper class which loosely  follows an adapter and bridge pattern with the wxWidgets library, though this interaction is not depicted because the class structure of the library is very complex and non-essential to this application's design.


===5.2 Transfer Manager===

The Transfer Manager subsystem is comprised of several classes responsible for allowing access to the Torrent Transfer Manager and HTTP Transfer Manager easily.  The subsystem's classes are pictured below:

http://nmt-cs326-g5.googlecode.com/files/class_transfermanager.JPG

The subsystem's internal associations and remote connection to the content server are depicted below:

http://nmt-cs326-g5.googlecode.com/files/ssinteraction_transfermanager.jpeg

The primary object in this subsystem is the TransferManager interface, which all file transfer classes must realize in order to be compatible with the system.  This allows for a large amount extensibility and generality of 'file transfer' within the system, as new classes which implemented file transfer over different protocols could easily be created.

The next most important objects are the HTTPTransferManager and the TorrentTransferManager classes, which will be discussed in sections 5.2.1 and 5.2.2, respectively.

The subsystem also defines the Download interface, which all file handling classes must realize in a similar manner to the TransferManager interface in order to handle local file transactions.  This section of the subsystem is the link the the Local File Storage subsystem in the Model section of the subsystem architecture.  The Download interface implements methods which are useful for reporting information about a file _transfer_, such as the current download speed or percentage completion.

In addition, all classes which implement the Download interface also aggregate the File class, which is a concrete object which has many attributes common to all files.


*5.2.1 HTTP Transfer Manager*

Pictured above (section 5.2), the HTTP Transfer Manager subsystem is comprised of two classes: the HTTPTransferManager class and the HTTPDownload class.

The HTTP Transfer Manager subsystem handles the transfer of files over the HTTP as well as any standard HTTP requests, such as HEAD and GET, that are required.   

*5.2.2 Torrent Transfer Manager*

The Torrent Transfer Manager is responsible for managing the torrent transfers.  It will communicate with the tracker, the seeds, and the peers to efficiently transfer the torrents. This subsystem will also download and seed the torrent, as well as report statistics on the current torrent transfers.

===5.3 Database Manager===

===5.4 Content Manager===

==6. Human Interfaces==

Mockup designs for each user interface.

==7. System/Data Dependencies & Requirements==

These are drawn primarily from supplementary requirements.

==8. Testing Plan==

==9. Appendices==

===Database Schemas===

The following is an entity relationship diagram depicting the database:
http://nmt-cs326-g5.googlecode.com/files/db_er.jpeg

===9.1 Project Status===