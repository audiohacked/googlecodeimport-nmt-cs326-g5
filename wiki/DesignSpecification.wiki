#summary We can do our design specification here.

=Digital Content Distribution and Publishing System=
==Team # 5==

=Design Specification=

==1. Project Overview==

The program will provide a cross-platform content distribution and publishing service. It will use a client-server model where the server will use and provide service through standard programs/services like Apache and MySQL. The customer can choose to use the server to distribute published files or allow users to upload their own content that can be sponsored/featured on the server.

The motivation for this project is the lack of a general-purpose, platform-independent content distribution service on the market.  Many content distribution services, such as Valve's Steam platform for game distribution, Apple's iTunes service for music distribution, or Netflix's online movie watching software, have some form of platform-dependency (whether it be a an operating system or browser) and/or are content-specific; that is to say that they allow the distribution of only certain forms of digital content.


===1.1 Scope and Objectives===

The scope of the project is to build a base platform for customers to create a digital community and publishing system while also supporting at least Linux, Windows, and Mac users alike. The main function of the system is to provide an end-user a way to obtain any digital content, such as movies, music, and other entertainment. The system has to be fast, native-looking, and easily changeable/upgradeable. To insure the user's client is up to date, it will include an self updater. To facilitate downloading, the client will use BitTorrent and HTTP. Finally, the client can also be configured to include Community Portal and/or a web browser.

===1.2 Supplementary Requirements===

*FURPS Non-functional Requirements (Quality)*

_Usability_
  * Users familiar with other content distribution platforms and file transfer clients should feel at ease with this system.
  * User interface should always strive for simplicity and intuitiveness.
  * User interface should follow a tabbed system to divide functionality and reduce complexity.

_Reliability_
  * The entire system must be robust enough to handle common networking issues like dropped connections, missing files, and transfer errors.
  * User authentication system should use common security practices.

_Performance_
  * File transfers should initiate within two seconds of a client's request.
  * Content server should responsibly manage available bandwidth to achieve optimal browsing and transfer speeds.

_Supportability_
  * Content server's closed website system should be mostly dynamic, adapting to file additions/removals as well as changes in existing files' properties.

*FURPS+ Additional Non-functional Requirements (Constraints)*

_Implementation_
  * The client will be implemented in C++, utilizing the gtkWidgets library for cross-platform code.

----

==2. Customer Requirements==
*Use-Case Diagram - Entire System*

http://nmt-cs326-g5.googlecode.com/files/usecasev2_2.jpeg

*Actor Descriptions and Use-Cases by Actor*

`BasicUser` - the target audience for downloads, uses the client software.

http://nmt-cs326-g5.googlecode.com/files/UseCase_BasicUser.jpeg

----

`ContentDistributor` - the manager of the Centralized Content Server, inherits functionality from Basic User.

http://nmt-cs326-g5.googlecode.com/files/UseCase_ContentDistributor.jpeg

----

`DBManager` - provides storage and retrieval for information on downloads. This includes file location, file attributes, statistics including number of downloads, and other vital information.

http://nmt-cs326-g5.googlecode.com/files/UseCase_Database.jpeg

----

`ContentServer` - communicates with the client software and the database. Is responsible for communication between client and database.

http://nmt-cs326-g5.googlecode.com/files/UseCase_ContentServer.jpeg

----

`Tracker` - communicates with the client software during a torrent download to provide connection information to peers.

http://nmt-cs326-g5.googlecode.com/files/UseCase_Tracker.jpeg


*Deployment Diagram*

http://nmt-cs326-g5.googlecode.com/files/DeploymentDiagram.jpeg

----

==3. Architectural Design==

Our project is utilizing the Model-View-Controller (MVC) architecture to effectively reduce complexity and separate application entities (files, database storage) from business logic (file transfer) and boundary entities (user interface).  

Other architectures were considered, including the Client-Server model and Peer-To-Peer model, but these architectures only encompass part of the functionality of application.  We have, however, adhered to many of the guiding principles behind these architectures while structuring our application under MVC.

===3.1 Subsystem Architecture===

This section should include a subsystem dependency diagram and supporting discussion. 
http://nmt-cs326-g5.googlecode.com/files/subsystem_architecture_v1.jpeg

This diagram is divided into three distinct layers; model, view, and controller.  Following the MVC architecture and philosophy, subsystems performing boundary actions are in the view layer.  These subsystems consist of the User Interface (composed of the GUI and in-house web browser subsystems) and the Server subsystem.  The User Interface handles virtually every interaction with the user, the Server subsystem represents the centralized content server with which the client interacts.

The controller layer consists of subsystems which perform the vast majority of business logic for the application.  This layer contains the wxWidgets, Transfer Manager, Database Manager, and Content Manager subsystems.  The wxWidgets system represents the wxWidgets API, which allows our application to be platform-independent and is responsible for rendering the client and implementing the web browser.  The TransferManager is an abstract subsystem, realized by two subsystems, the HTTP Transfer Manager and the Torrent Transfer Manager, which handle and implement the code to perform transfers over their respective protocols between clients and the centralized content server, as well as between clients (in the case of a torrent transfer) and a tracker.  The Database Manager subsystem is responsible for handling requests from both client and server concerning the centralized database, as well as connecting to and performing transactions with that database.  Finally, the Content Manager subsystem is a server-side subsystem which manages requests for files from clients.  The Content Manager also provides the necessary functionality to perform user authentication and administrative actions for users who are "Content Distributors".  

The lowest level of the architecture is the model layer, and is comprised of only three subsystems; an OS-specific GUI Library, the Local File System, and a mySQL Database.   The OS-specific GUI Library is a dynamic system, controlled by the wxWidgets subsystem to perform rendering actions on a specific operating system.  The internal class hierarchy related to these subsystems follows a bridge design pattern for separating the implementation of GUI concepts (windows, menus, dialogs, etc.) from an OS-specific implementation of those concepts.  The second subsystem, the Local File System, is also a generic subsystem which is largely implemented by system API's.  This subsystem is responsible for storing files which are downloaded to clients and uploaded by clients to the content server.  Finally, the third subsystem, the mySQL Database, consists of the actual relational schema and physical tables of application data in the mySQL DBMS.  This subsystem is controlled exclusively by the Database Manager subsystem.


===3.2 Deployment Model===

http://nmt-cs326-g5.googlecode.com/files/deployment_diagram_v2.JPG

The deployment model for the application is fairly traditional; client-side systems are mapped to the client executable, server systems (Content Manager) are mapped to a server side applet, and the database subsystem is mapped to a mySQL database.  One content server supports many clients, and one database instance is tied to one server.  

----

==4. Use Case Realization Design==

Specific use case descriptions and sequence diagrams:

_Use Case Name_      *`DownloadFile`* _(Also applies to *'DownloadHTTPFile'*)_

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_abstractdownload.jpeg

http://nmt-cs326-g5.googlecode.com/files/downloadFileClassDiagram.png

This generic use case includes all more specific download use cases, which include HTTP and Torrent downloads, at this time. The Basic User selects the download in the GUI, which then communicates the request for the download to the proper TransferManager, which is specific to each type of transfer. The transfer manager then initiates a connection with the server to be downloaded from, using information from the ContentManager server.

----

_Use Case Name_        *`DownloadTorrentFile`*

http://nmt-cs326-g5.googlecode.com/files/seq_downloadtorrentfile.jpg

http://nmt-cs326-g5.googlecode.com/files/downloadTorrentFileClassDiagram.png

The user selects a file or set of files to download, which are associated with the torrent download type. The GUI then communicates the download request to the Torrent Transfer Manager, which then communicates with the ContentManager to get the proper information, as well as the torrent file. The Torrent Transfer Manager then interprets the torrent file and the location of the torrent tracker. The Torrent Transfer Manager then communicates with the torrent tracker and receives the location of peers with the desired download.


----

_Use Case Name_      *`ReportFileDownload`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_reportfiledownload.jpeg

http://nmt-cs326-g5.googlecode.com/files/reportFileDownloadClassDiagram.png

The ContentManager checks to be sure it has an open connection to the DBManager, which manages the actual connection to the database. If the connection is ready, the ContentManager communicates it's request to the DBManager, and then DBManager signals it is ready for the data. ContentManager then communicates the report of the file download, which is then inserted into the database. DBManager then reports to ContentManager its success or failure.

----

_Use Case Name_  *`ReportFileUpload`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_reportfileupload.jpeg

http://nmt-cs326-g5.googlecode.com/files/ReportFileUploadClassDiagram.png

The ContentManager checks to be sure it has an open connection to the DBManager, which manages the actual connection to the database. If the connection is ready, the ContentManager communicates it's request to the DBManager, and then DBManager signals it is ready for the data. ContentManager then communicates the report of the file upload, including the attributes and location of the file, which is then inserted into the database. DBManager then reports to ContentManager its success or failure.

----

_Use Case Name_  *`UploadFile`*

*Activity Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_uploadfile.jpg

http://nmt-cs326-g5.googlecode.com/files/UploadFileClassDiagram.png

The authenticated user communicates a request to the content manager to upload a file. The content manager checks with the database if the user is allowed to upload files. If the user is properly authorized, they select the file type and location, and upload the file to the server. The user is prompted by the GUI for information pertaining to the file, and the content manager receives the file and information, and inserts the proper data into the database through the DBManager.

----

_Use Case Name_  *`DesignateFileSponsoredStatus`*

http://nmt-cs326-g5.googlecode.com/files/seq_designatefilesponsoredstatus.jpg

http://nmt-cs326-g5.googlecode.com/files/designateFileSponsoredStatusClassDiagram.png

An authenticated user uses the GUI to select a file that they want to designate the sponsored status upon. The GUI then contacts the Content Manager, which then checks with DBManager to make sure the user is a Content Distributor. If the user is a Content Distributor, then the original request is carried out by the Content Manager, which sends the proper command to the DBManager.

----

_Use case name_  *`GetFileStatistics`*


http://nmt-cs326-g5.googlecode.com/files/seq_getfilestatistics.jpg

http://nmt-cs326-g5.googlecode.com/files/GetFileStatisticsClassdiagram.png

The Content Manager requests file statistics through the DBManger, which has the actual connection to the database. The DBManager responds with either the data or an error code.
----

_Use case name_  *`ReportTransferProgress`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_reporttransferprogress2.JPG

http://nmt-cs326-g5.googlecode.com/files/ReportTransferProgressClassD.png

The GUI requests the progress of a transfer from a specific Transfer Manager. The Transfer Manager returns the progress (an integer from 0-100) or an error message.
----

_Use case name_  *`BrowseContentSite`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_browsecontent.jpeg

This use case covers the in-client web browsing of the centralized content server.  Essentially, a user requests a particular web page; the GUI relays the request to the ContentManager class, which then returns the requested data to the client, which is then rendered by the GUI.

http://nmt-cs326-g5.googlecode.com/files/browseContentSiteClassDiagram2.png

This interaction involves two classes; the GUI and the ContentManager.  The multiplicity of this relationship merely indicates that one ContentManager can service multiple GUI's (client applications).

----

_Use case name_  *`RemoveFile`*

*Activity Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_removefile.jpg

http://nmt-cs326-g5.googlecode.com/files/removeFileClassDiagram2.png

An authenticated user makes a request to the Content Manager through the GUI to remove a download from the server. The Content Manger communicates with the DBManager and confirms that the user is allowed to delete files from the server. The Content Manger then sends the request to the DBManager to delete the file information, and, if successful, deletes the actual file. If unsucessful, an error message is returned to the GUI and displayed to the user.

----

_Use case name_  *`SetClientPreferences`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_setclientpreferences.jpeg

http://nmt-cs326-g5.googlecode.com/files/SetClientPreferencesClassDiagram.png

A basic user selects a 'preferences' menu item in the GUI. The GUI then initializes the preference dialog, which reads the user's preferences from a local configuration file. The user can then change their preferences through the preference dialog, which can then be saved.

----

_Use case name_  *`SetServerPreferences`*

*Sequence Diagram*

http://nmt-cs326-g5.googlecode.com/files/seq_setserverpreferences.jpeg

http://nmt-cs326-g5.googlecode.com/files/SetServerPreferencesClassDiagram.png

An authenticated Content Distributor selects the option to set the server preferences in the GUI. The GUI then communicates the request to the Content Manager. The Content Manager then contacts the DBManager to see if the user is in fact a Content Distributor and not a regular user. If the user is allowed to edit the server preferences, the Content Manager notifies the GUI and a modified Preference Dialog is initialized. The Content Distributor can then edit various settings and commit them to the Content Manager, or cancel the process.

----

_Use Case Name_        *`AbortFileTransfer`*

*Activity Diagram*

http://nmt-cs326-g5.googlecode.com/files/act_aborttransfer.jpeg

http://nmt-cs326-g5.googlecode.com/files/abortFileTransferClassDiagram.png

A Basic User selects a download within the GUI and presses the cancel button. The GUI then communicates with the proper transfer manager (depending on the type of transfer), which then stops the download, deletes the file, and notifies the GUI, which in turn notifies the user.

----

==5. Subsystem Design==

===5.1 User Interface===
This set of subsystems is comprised entirely of one class, the 'GUI' class.  This class is pictured below:

http://nmt-cs326-g5.googlecode.com/files/class_gui_v2.JPG

The subsystem's internal associations are depicted below:

http://nmt-cs326-g5.googlecode.com/files/ssinteraction_ui_v1.jpeg

The functionality of this class is described in terms of the next three subsystems of the User Interface.

*5.1.1 GUI*

This subsystem implements the graphical user interface via the wxWidgets libraries.  When the GUI class is invoked (via the invoke() method), it establishes all the necessary wxWidgets components and events to manage the graphical user interface.  In addition, methods like openPreferenceDialog() and initiateUpload() handle common boundary actions between users and the client.  

*5.1.2 Web Browser*

The Web Browser subsystem is handled entirely by the viewWebContent() method.  This method handles the transfer of web content from the ContentManager class (see the Content Manager subsystem) and is primarily responsible for displaying web content via the in-house browser and passing along download requests to other subsystems via methods like initiateDownload().

*5.1.3 wxWidgets*

The wxWidgets subsystem represents the wxWidgets library, which the application makes heavy use of in order to create a cross-platform client which maintains the "look and feel" of a native application.  The GUI class is essentially a wrapper class which loosely  follows an adapter and bridge pattern with the wxWidgets library, though this interaction is not depicted because the class structure of the library is very complex and non-essential to this application's design.


===5.2 Transfer Manager===

The Transfer Manager subsystem is comprised of several classes responsible for allowing access to the Torrent Transfer Manager and HTTP Transfer Manager easily.  The subsystem's classes are pictured below:

http://nmt-cs326-g5.googlecode.com/files/class_transfermanager.JPG

The subsystem's internal associations and remote connection to the content server are depicted below:

http://nmt-cs326-g5.googlecode.com/files/ssinteraction_transfermanager.jpeg

The primary object in this subsystem is the TransferManager interface, which all file transfer classes must realize in order to be compatible with the system.  This allows for a large amount extensibility and generality of 'file transfer' within the system, as new classes which implemented file transfer over different protocols could easily be created.

The next most important objects are the HTTPTransferManager and the TorrentTransferManager classes, which will be discussed in sections 5.2.1 and 5.2.2, respectively.

The subsystem also defines the Download interface, which all file handling classes must realize in a similar manner to the TransferManager interface in order to handle local file transactions.  This section of the subsystem is the link the the Local File Storage subsystem in the Model section of the subsystem architecture.  The Download interface implements methods which are useful for reporting information about a file _transfer_, such as the current download speed or percentage completion.

In addition, all classes which implement the Download interface also aggregate the File class, which is a concrete object which has many attributes common to all files.


*5.2.1 HTTP Transfer Manager*

The HTTP Transfer Manager subsystem handles the transfer of files over the HTTP as well as any standard HTTP requests, such as HEAD and GET, that are required.

Pictured below, the HTTP Transfer Manager subsystem is comprised primarily of two classes: the HTTPTransferManager class and the HTTPDownload class.

http://nmt-cs326-g5.googlecode.com/files/class_httptransfer.JPG

The HTTPTransferManager implements one additional method: downloadFile().  This method is responsible for contacting the content server (the request is handled by the server-side Content Manager subsystem) and requesting a file.  The methods of the TransferManager interface are implemented in a manner that utilizes HTTP.

The HTTPDownload class is a simple class which necessarily implements the Download interface. It implements one additional method, getFileName() which retrieves the name of the file associated with the object.

*5.2.2 Torrent Transfer Manager*

The Torrent Transfer Manager is responsible for managing the torrent transfers.  It will communicate with the tracker, the seeds, and the peers to efficiently transfer the torrents. This subsystem will also download and seed the torrent upon completion of the download.  

Pictured below, the Torrent Transfer Manager subsystem is likewise comprised of primarily of two classes: the TorrentTransferManager class and the TorrentDownload class.

http://nmt-cs326-g5.googlecode.com/files/class_torrenttransfer.JPG

The TorrentTransferManager implements two additional methods: downloadTorrent() and connectToTracker().  The downloadTorrent() method works similarly to the HTTPTransferManager's downloadFile() method, except it targets a torrent file on the content server.  Upon completion of the torrent file transfer, the class utilizes the connectToTracker() method to connect to the torrent file's designated tracker(s).  The TorrentTransferManager implements the Transfer Manager interface in such a way to manage the peer to peer connections of the BitTorrent protocol, most likely using libtorrent.

The TorrentFile class realizes the Download interface, but also has many additional attributes.  These include an array of File objects (as a torrent download often contains several files), an address to the tracker (trackerLocation), as well as an updating list of peer addresses (peerLocations).

===5.3 Database Manager===
The Database Manager subsystem is a subsystem common to both the client and server applications, though each instance performs somewhat differently in the context of these different systems.  This system is responsible for connecting to a mySQL database as well as handling high-level (i.e., retrieving the top 10 downloads) and, internally, simple transactions (inserting a new record, for example) with the database.  

The subsystem's internal associations are depicted here:

http://nmt-cs326-g5.googlecode.com/files/ssinteraction_db_2.JPG

Pictured below, the Database Manager subsystem is implemented via a single class:

http://nmt-cs326-g5.googlecode.com/files/class_db.JPG

The DBManager implements several important methods, the first of which are the dbConnect() and dbDisconnect() methods.  These methods connect to and disconnect from the database according to the connectionString and databaseType attributes.

The dbSelect(), dbInsert(), dbDelete(), and dbEdit() methods implement the simple SQL transactions (SELECT, INSERT, DELETE, and UPDATE), respectively.  These methods are private, as the DBManager's purpose is to provide a high-level black-box interface to the application's database functionality.  

The reportFileDownload() and reportFileUpload()/addFiletoDB()/addTorrenttoDB() methods alter the database to increment a download count on a particular file or create a new record for newly added content.  The designateFileSponsoredStatus() is a method used by Content Distributors (Administrative users and sometimes normal users) to set the sponsored flag on a file's record, which will then promote the file to "sponsored" status.  

===5.4 Content Manager===
The Content Manager subsystem is a server-side system which handles requests from zero to many client systems.  It also filters database requests from the client and passes them along to the Database Manager subsystem (this is to keep consistent with the MVC architecture) as well as making its own requests to the database.  

The Content Manager's internal associations, as well as remote associations to the database and clients are depicted below:

http://nmt-cs326-g5.googlecode.com/files/ssinteraction_cm_v2.JPG

The Content Manager is implemented via a single class, ContentManager, pictured below:

http://nmt-cs326-g5.googlecode.com/files/class_cm.JPG

The ContentManager implements several methods to handle various requests from clients.  The connect() and disconnect() methods handle the connection and handshaking process between server and client, as well as authentication (via the getUserPermissions() method).  The browseContentSite() method retrieves a web page and sends it to the requesting client (who requested it via the Web Browser subsystem).  

The getFileLocation() method is used for file transfer requests (as all requests for file transfer to the content server occur over HTTP, this method is blind to the type of file requested apart from basic security considerations).  The setServerPreferences() method is used to set various server and community options (like whether or not basic users are allowed to upload content, creating a toggle between an open and closed file distribution community), and can only be used by Content Distributors, who are authenticated by the methods previously discussed.

Finally, the reportCompletedDownload() method uses the Database Manager subsystem to report a completed file transfer and update the file's statistics (download count, etc). 

----

==6. Human Interfaces==
The following are two screenshots of a sample client, running first in Windows Vista, the second in Macintosh OS X.  

Vista:
http://nmt-cs326-g5.googlecode.com/files/winvista.png

OS X:
http://nmt-cs326-g5.googlecode.com/files/macosx.png

The following is a screenshot of a client with the Web Browser subsystem implemented; the client is capable of an in-house web browsing via an internal Firefox implementation.

http://nmt-cs326-g5.googlecode.com/files/Capture.PNG

----

==7. System/Data Dependencies & Requirements==

These are drawn primarily from supplementary requirements.

----

==8. Testing Plan==

----

==9. Appendices==

===Database Schemas===

The following is an entity relationship diagram depicting the database:
http://nmt-cs326-g5.googlecode.com/files/db_er.jpeg

===9.1 Project Status===